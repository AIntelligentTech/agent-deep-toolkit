#!/usr/bin/env bash
set -euo pipefail

SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(dirname "$SCRIPT_DIR")"
CACE_VERSION="2.5.1"
CACE_DIR="/home/tony/business/tools/cross-agent-compatibility-engine"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

log_info() { echo -e "${BLUE}[info]${NC} $*"; }
log_success() { echo -e "${GREEN}[ok]${NC} $*"; }
log_warn() { echo -e "${YELLOW}[warn]${NC} $*"; }
log_error() { echo -e "${RED}[error]${NC} $*" >&2; }
log_section() { echo -e "\n${CYAN}═══ $* ═══${NC}\n"; }

usage() {
  cat <<USAGE
Usage: $SCRIPT_NAME [--agents <agents>] [--skip-variants] [--skip-validation] [--health-check] [--force-cace-install] [--dry-run]

Agents (comma-separated, or 'all' for toolkit-supported agents):
  claude,windsurf,cursor,opencode

Options:
  --agents <agents>       Agent list (default: claude,windsurf,cursor,opencode)
  --skip-variants         Skip alias/synonym variant generation
  --skip-validation       Skip CACE validation after conversion
  --health-check          Run health check and exit
  --force-cace-install    Force reinstallation of CACE CLI
  --dry-run               Preview without making changes

Examples:
  $SCRIPT_NAME --agents claude,windsurf,cursor,opencode
  $SCRIPT_NAME --agents all --health-check
  $SCRIPT_NAME --skip-validation
USAGE
}

check_node_version() {
  local node_version
  node_version=$(node --version 2>/dev/null | cut -d'v' -f2 | cut -d'.' -f1)
  if [ -z "$node_version" ] || [ "$node_version" -lt 18 ]; then
    log_error "Node.js >= 18.0.0 required. Found: $(node --version 2>/dev/null || echo 'not installed')"
    exit 1
  fi
  log_success "Node.js version: $(node --version)"
}

check_cace_installation() {
  if [ -f "$CACE_DIR/dist/cli/index.js" ]; then
    log_info "Using local CACE: $CACE_DIR"
    return 0
  fi
  
  log_info "Local CACE not found. Attempting npm install..."
  
  if command -v npm &> /dev/null; then
    npm install -g "cace-cli@$CACE_VERSION" 2>/dev/null || {
      log_warn "npm install failed"
    }
  fi
  
  if command -v cace &> /dev/null; then
    log_success "CACE installed via npm"
  else
    log_error "CACE not found. Please ensure CACE is available at: $CACE_DIR"
    exit 1
  fi
}

run_cace() {
  if [ -f "$CACE_DIR/dist/cli/index.js" ]; then
    node "$CACE_DIR/dist/cli/index.js" "$@"
  else
    cace "$@"
  fi
}

install_cace() {
  log_info "Installing CACE v$CACE_VERSION via npm..."
  
  if command -v npm &> /dev/null; then
    npm install -g "cace-cli@$CACE_VERSION" 2>/dev/null || {
      log_warn "npm install failed"
    }
  fi
  
  if command -v cace &> /dev/null; then
    log_success "CACE installed via npm"
  else
    log_error "CACE npm install failed. Local CACE will be used if available."
  fi
}

run_cace() {
  if [ -f "$CACE_DIR/dist/cli/index.js" ]; then
    node "$CACE_DIR/dist/cli/index.js" "$@"
  elif command -v cace &> /dev/null; then
    cace "$@"
  else
    log_error "CACE not available"
    exit 1
  fi
}

convert_skills() {
  local agents=("$@")
  local skills_dir="$REPO_ROOT/skills"
  local outputs_dir="$REPO_ROOT/outputs"
  
  if [ ! -d "$skills_dir" ]; then
    log_error "Skills directory not found: $skills_dir"
    exit 1
  fi
  
  local skill_count
  skill_count=$(find "$skills_dir" -maxdepth 1 -mindepth 1 -type d | wc -l)
  log_info "Converting $skill_count skills to ${#agents[@]} agents..."
  
  log_section "Cleaning outputs directory"
  if [ -d "$outputs_dir" ]; then
    rm -rf "$outputs_dir"
  fi
  mkdir -p "$outputs_dir"
  
  for agent in "${agents[@]}"; do
    log_info "Converting to $agent..."
    
    local agent_output="$outputs_dir/$agent"
    mkdir -p "$agent_output"
    
    # Some targets use dual-output strategy for parity/compatibility.
    # - Windsurf: workflows (manual) + skills (auto)
    # - Cursor: skills (auto/progressive) + commands (explicit manual)
    local strategy="direct"
    if [ "$agent" = "windsurf" ]; then
      strategy="dual-output"
      log_info "Using dual-output strategy for Windsurf (preserves auto-invocation + manual /command)"
      # Create skills directory structure for dual-output
      mkdir -p "$agent_output/.windsurf/skills"
    elif [ "$agent" = "cursor" ]; then
      strategy="dual-output"
      log_info "Using dual-output strategy for Cursor (skills + commands)"
      mkdir -p "$agent_output/.cursor/skills" "$agent_output/.cursor/commands"
    fi
    
    if run_cace convert-dir "$skills_dir" \
      --to "$agent" \
      --strategy "$strategy" \
      --output "$agent_output" \
      --backup false 2>&1 | grep -q "error"; then
      log_warn "Conversion to $agent completed with warnings"
    else
      log_success "Converted to $agent"
    fi
  done
}

rewrite_skill_frontmatter_for_variant() {
  local skill_file="$1"
  local new_name="$2"
  local new_command="/$2"

  # Rewrite only inside the first YAML frontmatter block.
  # Cursor/Windsurf require `name` to match the parent folder name.
  local tmp
  tmp="$(mktemp)"
  awk -v name="$new_name" -v cmd="$new_command" '
    BEGIN { in_front = 0; seen_front = 0; wrote_name = 0; wrote_cmd = 0; wrote_aliases = 0; wrote_synonyms = 0 }
    seen_front == 0 && $0 ~ /^---[[:space:]]*$/ { in_front = 1; seen_front = 1; print; next }
    in_front == 1 {
      if ($0 ~ /^---[[:space:]]*$/) {
        if (wrote_name == 0) { print "name: " name }
        if (wrote_cmd == 0) { print "command: " cmd }
        if (wrote_aliases == 0) { print "aliases: []" }
        if (wrote_synonyms == 0) { print "synonyms: []" }
        in_front = 0
        print
        next
      }
      if ($0 ~ /^name:[[:space:]]*/) { print "name: " name; wrote_name = 1; next }
      if ($0 ~ /^command:[[:space:]]*/) { print "command: " cmd; wrote_cmd = 1; next }
      if ($0 ~ /^aliases:[[:space:]]*/) { print "aliases: []"; wrote_aliases = 1; next }
      if ($0 ~ /^synonyms:[[:space:]]*/) { print "synonyms: []"; wrote_synonyms = 1; next }
      print
      next
    }
    { print }
  ' "$skill_file" > "$tmp"
  mv "$tmp" "$skill_file"
}

generate_variants() {
  local outputs_dir="$REPO_ROOT/outputs"
  local skills_dir="$REPO_ROOT/skills"
  
  log_section "Generating alias/synonym variants"
  
  for agent_dir in "$outputs_dir"/*/; do
    [ -d "$agent_dir" ] || continue
    local agent
    agent=$(basename "$agent_dir")
    
    log_info "Processing $agent..."
    local variant_count=0

    # Variants must be generated in the user-visible surfaces for each agent:
    #
    # - Claude: `.claude/skills/<name>/SKILL.md` (skill directories)
    # - Cursor: `.cursor/skills/<name>/SKILL.md` + `.cursor/commands/<name>.md`
    # - Windsurf: `.windsurf/skills/<name>/SKILL.md` + `.windsurf/workflows/<name>.md`
    # - OpenCode: `.opencode/<name>/SKILL.md` directories (installer maps to `<name>.md`)
    if [ "$agent" = "windsurf" ]; then
      local workflows_dir="$agent_dir/.windsurf/workflows"
      local skills_root="$agent_dir/.windsurf/skills"

      # Workflows (.md)
      if [ -d "$workflows_dir" ]; then
        while read -r md_file; do
          local skill_name
          skill_name=$(basename "$md_file" .md)

          local source_skill="$skills_dir/$skill_name/SKILL.md"
          [ -f "$source_skill" ] || continue

          local aliases synonyms
          aliases=$(grep -E '^\s*aliases:' "$source_skill" 2>/dev/null || echo "")
          synonyms=$(grep -E '^\s*synonyms:' "$source_skill" 2>/dev/null || echo "")

          for alias in $(echo "$aliases" | grep -oP '"/[^"]+"' | tr -d '"' | tr -d '/'); do
            if [ -n "$alias" ] && [ "$alias" != "$skill_name" ] && [ ! -f "$workflows_dir/${alias}.md" ]; then
              cp "$md_file" "$workflows_dir/${alias}.md"
              ((variant_count++)) || true
            fi
          done

          for synonym in $(echo "$synonyms" | grep -oP '"/[^"]+"' | tr -d '"' | tr -d '/'); do
            if [ -n "$synonym" ] && [ "$synonym" != "$skill_name" ] && [ ! -f "$workflows_dir/${synonym}.md" ]; then
              cp "$md_file" "$workflows_dir/${synonym}.md"
              ((variant_count++)) || true
            fi
          done
        done < <(find "$workflows_dir" -maxdepth 1 -name "*.md" 2>/dev/null)
      fi

      # Skills (directories)
      if [ -d "$skills_root" ]; then
        while read -r skill_file; do
          local skill_dir skill_name
          skill_dir="$(dirname "$skill_file")"
          skill_name="$(basename "$skill_dir")"

          local source_skill="$skills_dir/$skill_name/SKILL.md"
          [ -f "$source_skill" ] || continue

          local aliases synonyms
          aliases=$(grep -E '^\s*aliases:' "$source_skill" 2>/dev/null || echo "")
          synonyms=$(grep -E '^\s*synonyms:' "$source_skill" 2>/dev/null || echo "")

          for alias in $(echo "$aliases" | grep -oP '"/[^"]+"' | tr -d '"' | tr -d '/'); do
            if [ -n "$alias" ] && [ "$alias" != "$skill_name" ] && [ ! -d "$skills_root/$alias" ]; then
              cp -R "$skill_dir" "$skills_root/$alias"
              if [ -f "$skills_root/$alias/SKILL.md" ]; then
                rewrite_skill_frontmatter_for_variant "$skills_root/$alias/SKILL.md" "$alias"
              fi
              ((variant_count++)) || true
            fi
          done

          for synonym in $(echo "$synonyms" | grep -oP '"/[^"]+"' | tr -d '"' | tr -d '/'); do
            if [ -n "$synonym" ] && [ "$synonym" != "$skill_name" ] && [ ! -d "$skills_root/$synonym" ]; then
              cp -R "$skill_dir" "$skills_root/$synonym"
              if [ -f "$skills_root/$synonym/SKILL.md" ]; then
                rewrite_skill_frontmatter_for_variant "$skills_root/$synonym/SKILL.md" "$synonym"
              fi
              ((variant_count++)) || true
            fi
          done
        done < <(find "$skills_root" -maxdepth 2 -name "SKILL.md" 2>/dev/null)
      fi
    elif [ "$agent" = "cursor" ]; then
      local commands_dir="$agent_dir/.cursor/commands"
      local skills_root="$agent_dir/.cursor/skills"

      # Commands (.md)
      if [ -d "$commands_dir" ]; then
        while read -r md_file; do
          local skill_name
          skill_name=$(basename "$md_file" .md)

          local source_skill="$skills_dir/$skill_name/SKILL.md"
          [ -f "$source_skill" ] || continue

          local aliases synonyms
          aliases=$(grep -E '^\s*aliases:' "$source_skill" 2>/dev/null || echo "")
          synonyms=$(grep -E '^\s*synonyms:' "$source_skill" 2>/dev/null || echo "")

          for alias in $(echo "$aliases" | grep -oP '"/[^"]+"' | tr -d '"' | tr -d '/'); do
            if [ -n "$alias" ] && [ "$alias" != "$skill_name" ] && [ ! -f "$commands_dir/${alias}.md" ]; then
              cp "$md_file" "$commands_dir/${alias}.md"
              ((variant_count++)) || true
            fi
          done

          for synonym in $(echo "$synonyms" | grep -oP '"/[^"]+"' | tr -d '"' | tr -d '/'); do
            if [ -n "$synonym" ] && [ "$synonym" != "$skill_name" ] && [ ! -f "$commands_dir/${synonym}.md" ]; then
              cp "$md_file" "$commands_dir/${synonym}.md"
              ((variant_count++)) || true
            fi
          done
        done < <(find "$commands_dir" -maxdepth 1 -name "*.md" 2>/dev/null)
      fi

      # Skills (directories)
      if [ -d "$skills_root" ]; then
        while read -r skill_file; do
          local skill_dir skill_name
          skill_dir="$(dirname "$skill_file")"
          skill_name="$(basename "$skill_dir")"

          local source_skill="$skills_dir/$skill_name/SKILL.md"
          [ -f "$source_skill" ] || continue

          local aliases synonyms
          aliases=$(grep -E '^\s*aliases:' "$source_skill" 2>/dev/null || echo "")
          synonyms=$(grep -E '^\s*synonyms:' "$source_skill" 2>/dev/null || echo "")

          for alias in $(echo "$aliases" | grep -oP '"/[^"]+"' | tr -d '"' | tr -d '/'); do
            if [ -n "$alias" ] && [ "$alias" != "$skill_name" ] && [ ! -d "$skills_root/$alias" ]; then
              cp -R "$skill_dir" "$skills_root/$alias"
              if [ -f "$skills_root/$alias/SKILL.md" ]; then
                rewrite_skill_frontmatter_for_variant "$skills_root/$alias/SKILL.md" "$alias"
              fi
              ((variant_count++)) || true
            fi
          done

          for synonym in $(echo "$synonyms" | grep -oP '"/[^"]+"' | tr -d '"' | tr -d '/'); do
            if [ -n "$synonym" ] && [ "$synonym" != "$skill_name" ] && [ ! -d "$skills_root/$synonym" ]; then
              cp -R "$skill_dir" "$skills_root/$synonym"
              if [ -f "$skills_root/$synonym/SKILL.md" ]; then
                rewrite_skill_frontmatter_for_variant "$skills_root/$synonym/SKILL.md" "$synonym"
              fi
              ((variant_count++)) || true
            fi
          done
        done < <(find "$skills_root" -maxdepth 2 -name "SKILL.md" 2>/dev/null)
      fi
    elif [ "$agent" = "opencode" ]; then
      local opencode_root="$agent_dir/.opencode"
      if [ -d "$opencode_root" ]; then
        while read -r skill_file; do
          local skill_dir skill_name
          skill_dir="$(dirname "$skill_file")"
          skill_name="$(basename "$skill_dir")"

          local source_skill="$skills_dir/$skill_name/SKILL.md"
          [ -f "$source_skill" ] || continue

          local aliases synonyms
          aliases=$(grep -E '^\s*aliases:' "$source_skill" 2>/dev/null || echo "")
          synonyms=$(grep -E '^\s*synonyms:' "$source_skill" 2>/dev/null || echo "")

          for alias in $(echo "$aliases" | grep -oP '"/[^"]+"' | tr -d '"' | tr -d '/'); do
            if [ -n "$alias" ] && [ "$alias" != "$skill_name" ] && [ ! -d "$opencode_root/$alias" ]; then
              cp -R "$skill_dir" "$opencode_root/$alias"
              if [ -f "$opencode_root/$alias/SKILL.md" ]; then
                rewrite_skill_frontmatter_for_variant "$opencode_root/$alias/SKILL.md" "$alias"
              fi
              ((variant_count++)) || true
            fi
          done

          for synonym in $(echo "$synonyms" | grep -oP '"/[^"]+"' | tr -d '"' | tr -d '/'); do
            if [ -n "$synonym" ] && [ "$synonym" != "$skill_name" ] && [ ! -d "$opencode_root/$synonym" ]; then
              cp -R "$skill_dir" "$opencode_root/$synonym"
              if [ -f "$opencode_root/$synonym/SKILL.md" ]; then
                rewrite_skill_frontmatter_for_variant "$opencode_root/$synonym/SKILL.md" "$synonym"
              fi
              ((variant_count++)) || true
            fi
          done
        done < <(find "$opencode_root" -maxdepth 2 -name "SKILL.md" 2>/dev/null)
      fi
    elif [ "$agent" = "claude" ]; then
      local skills_root="$agent_dir/.claude/skills"
      if [ -d "$skills_root" ]; then
        while read -r skill_file; do
          local skill_dir skill_name
          skill_dir="$(dirname "$skill_file")"
          skill_name="$(basename "$skill_dir")"

          local source_skill="$skills_dir/$skill_name/SKILL.md"
          [ -f "$source_skill" ] || continue

          local aliases synonyms
          aliases=$(grep -E '^\s*aliases:' "$source_skill" 2>/dev/null || echo "")
          synonyms=$(grep -E '^\s*synonyms:' "$source_skill" 2>/dev/null || echo "")

          for alias in $(echo "$aliases" | grep -oP '"/[^"]+"' | tr -d '"' | tr -d '/'); do
            if [ -n "$alias" ] && [ "$alias" != "$skill_name" ] && [ ! -d "$skills_root/$alias" ]; then
              cp -R "$skill_dir" "$skills_root/$alias"
              if [ -f "$skills_root/$alias/SKILL.md" ]; then
                rewrite_skill_frontmatter_for_variant "$skills_root/$alias/SKILL.md" "$alias"
              fi
              ((variant_count++)) || true
            fi
          done

          for synonym in $(echo "$synonyms" | grep -oP '"/[^"]+"' | tr -d '"' | tr -d '/'); do
            if [ -n "$synonym" ] && [ "$synonym" != "$skill_name" ] && [ ! -d "$skills_root/$synonym" ]; then
              cp -R "$skill_dir" "$skills_root/$synonym"
              if [ -f "$skills_root/$synonym/SKILL.md" ]; then
                rewrite_skill_frontmatter_for_variant "$skills_root/$synonym/SKILL.md" "$synonym"
              fi
              ((variant_count++)) || true
            fi
          done
        done < <(find "$skills_root" -maxdepth 2 -name "SKILL.md" 2>/dev/null)
      fi
    fi

    if [ "$variant_count" -gt 0 ]; then
      log_success "  Generated $variant_count variants for $agent"
    fi
  done
}

run_validation() {
  local outputs_dir="$REPO_ROOT/outputs"
  
  log_section "Validating converted skills"
  
  local total_score=0
  local agent_count=0
  local all_valid=true
  
  for agent_dir in "$outputs_dir"/*/; do
    [ -d "$agent_dir" ] || continue
    local agent
    agent=$(basename "$agent_dir")
    
    log_info "Validating $agent..."
    
    if run_cace validate "$agent_dir" --quiet 2>&1 | grep -q "error"; then
      log_warn "$agent: validation has issues"
      all_valid=false
    else
      local score
      score=$(run_cace validate "$agent_dir" --quiet 2>&1 | grep -oP '\d+(?=%)' | tail -1 || echo "100")
      total_score=$((total_score + score))
      agent_count=$((agent_count + 1))
      
      if [ "$score" -ge 90 ]; then
        log_success "  $agent: ${score}% health ✓"
      elif [ "$score" -ge 80 ]; then
        log_warn "  $agent: ${score}% health (below target 90%)"
      else
        log_error "  $agent: ${score}% health (critical)"
        all_valid=false
      fi
    fi
  done
  
  if [ "$agent_count" -gt 0 ]; then
    local avg_score=$((total_score / agent_count))
    echo ""
    log_info "Average health score: ${avg_score}%"
    
    if [ "$avg_score" -ge 90 ]; then
      log_success "Target of 90% health achieved!"
    else
      log_warn "Target of 90% health not met"
    fi
  fi
}

run_health_check() {
  log_section "CACE Health Check"
  
  if [ ! -f "$CACE_DIR/dist/cli/index.js" ] && ! command -v cace &> /dev/null; then
    log_error "CACE not available. Please ensure CACE is installed."
    exit 1
  fi
  
  log_success "CACE available: $CACE_DIR"
  log_success "Node.js: $(node --version)"
  
  local skill_count=0
  local output_count=0
  
  if [ -d "$REPO_ROOT/skills" ]; then
    skill_count=$(find "$REPO_ROOT/skills" -maxdepth 1 -mindepth 1 -type d | wc -l)
    log_success "Canonical skills: $skill_count"
  fi
  
  if [ -d "$REPO_ROOT/outputs" ]; then
    output_count=$(find "$REPO_ROOT/outputs" -name "*.md" | wc -l)
    log_success "Generated files: $output_count"
  fi
  
  echo ""
  run_cace doctor 2>/dev/null || log_info "CACE doctor not available"
}

main() {
  AGENTS="claude,windsurf,cursor,opencode"
  SKIP_VARIANTS=false
  SKIP_VALIDATION=false
  HEALTH_CHECK=false
  FORCE_CACE_INSTALL=false
  DRY_RUN=false
  
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --agents)
        AGENTS="${2:-}"
        shift 2
        ;;
      --skip-variants)
        SKIP_VARIANTS=true
        shift
        ;;
      --skip-validation)
        SKIP_VALIDATION=true
        shift
        ;;
      --health-check)
        HEALTH_CHECK=true
        shift
        ;;
      --force-cace-install)
        FORCE_CACE_INSTALL=true
        shift
        ;;
      --dry-run)
        DRY_RUN=true
        shift
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        log_error "Unknown argument: $1"
        usage
        exit 1
        ;;
    esac
  done

  # Expand "all" to the agent set this toolkit ships/installs.
  if [ "$AGENTS" = "all" ]; then
    AGENTS="claude,windsurf,cursor,opencode"
  fi
  
  log_section "Agent Deep Toolkit v3.0.0 - CACE Build System"
  log_info "CACE Version: $CACE_VERSION"
  
  if [ "$HEALTH_CHECK" = true ]; then
    check_node_version
    run_health_check
    exit 0
  fi
  
  check_node_version
  check_cace_installation
  
  IFS=',' read -ra AGENT_ARRAY <<< "$AGENTS"
  
  log_section "Conversion Phase"
  convert_skills "${AGENT_ARRAY[@]}"
  
  if [ "$SKIP_VARIANTS" = false ]; then
    generate_variants
  fi
  
  if [ "$SKIP_VALIDATION" = false ]; then
    run_validation
  fi
  
  log_section "Build Complete"
  log_info "Outputs written to: $REPO_ROOT/outputs/"
  log_info "Run './install.sh --agent all --level user' to install"
}

main "$@"
